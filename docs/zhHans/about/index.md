---
layout: home
title: 关于Tessera

hero:
  name: "关于 Tessera"
---

tessera 是一个跨平台的声明式和函数式 UI 库，专注于性能和可扩展性。

它源于[我](https://github.com/shadow3aaa/)期望有一个现代化，写起来简洁愉快的本地rust ui框架的愿望。

目前的 rust ui框架要么写起来较为繁琐，如 `iced` 的elm式组件，要么只能胜任简单的调试应用场景，如 `egui` ，或者像 `slint` 那样必须使用独立的 DSL 来定义 UI。我希望有一个纯 Rust 的框架，能够让开发者以一种简洁，不混乱，尽量符合直觉的方式来构建常见的本地应用 UI，同时具备高性能和良好的可扩展性。

## 组件模型

让组件模型贴近rust常见的编写模式非常重要。如果ui尝试引入一个很不同于逻辑代码的编写方式，使用它时就不得不在两种思维模式间切换。tessera力求始终符合直觉，这是必须避免的。

在rust中最常见的代码组织方式有两种，一种是使用struct和impl来表示主要逻辑，少量使用自由函数作为工具，另一种则是使用自由函数表示逻辑，stuct只用来表示数据，impl则作为工具使用。我不会说我知道哪一种方式更好，更"rust"，但tessera选择的是后者，因为我认为这种方式更简洁。

## 这里没有响应式编程

在谈论响应式编程之前，应该先明确我指的是状态的响应式更新，而非响应式ui设计。

响应式编程的核心思想是只在数据变化时更新使用它的部分ui以降低开销。这思想很自然的出现在web框架上，因为它们有一个非常昂贵，古老，过时的DOM更新过程需要优化。在非web的场景下，我不认为这是一个必要的设计。

ui性能优化的关键在于减少不必要的布局计算。减少布局计算并不代表持有一个巨大的组件树，里面拥有整个UI所有的状态，然后用一个比它轻量的算法去找出最小的更新部分，这只是古老而杂乱的web技术的遗留问题。

既然重布局是性能瓶颈，应该采用直接的优化方式。tessera将布局设计为一个无副作用，可并行化的过程，并且引入了自动缓存机制来避免重复计算，解决了布局性能问题。因此不需要响应式编程来影响开发体验并造成各种同步问题。
